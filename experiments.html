<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Experiments â€” Stefan Kelly</title>
  <link rel="stylesheet" href="styles.css">
  <style>
    .experiments-layout {
      display: grid;
      grid-template-columns: 230px minmax(0, 1fr);
      gap: 2rem;
      align-items: start;
    }

    .experiments-menu {
      position: sticky;
      top: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      border-left: 1px solid #ddd;
      padding-left: 1rem;
    }

    .experiment-tab {
      background: none;
      border: none;
      text-align: left;
      font-family: "Times New Roman", Times, serif;
      font-size: 0.95rem;
      color: #999;
      cursor: pointer;
      padding: 0.1rem 0;
    }

    .experiment-tab:hover,
    .experiment-tab:focus-visible {
      color: #000;
      outline: none;
    }

    .experiment-tab.active {
      color: #000;
      text-decoration: underline;
    }

    .experiments-content {
      min-height: 320px;
      position: relative;
      overflow: hidden;
    }

    .experiment-panel {
      display: none;
      max-width: 680px;
      animation: slide-in 220ms ease-out;
    }

    .experiment-panel.active {
      display: block;
    }

    @keyframes slide-in {
      from {
        opacity: 0;
        transform: translateX(14px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .experiment-title {
      margin-bottom: 0.4rem;
      font-size: 1.2rem;
    }

    .experiment-description {
      margin-bottom: 1.25rem;
      color: #333;
      max-width: 60ch;
    }

    .chat-container {
      max-width: 600px;
    }

    .chat-messages {
      margin-bottom: 1.5rem;
      min-height: 2rem;
    }

    .chat-message {
      margin-bottom: 1.25rem;
    }

    .chat-message.user {
      color: #999;
    }

    .chat-message.assistant {
      color: #000;
    }

    .chat-message .label {
      font-style: italic;
      font-size: 0.85rem;
      margin-bottom: 0.25rem;
    }

    .chat-input-row {
      display: flex;
      gap: 0.75rem;
      align-items: flex-end;
    }

    .chat-input {
      flex: 1;
      padding: 0.5rem 0;
      background: none;
      border: none;
      border-bottom: 1px solid #ccc;
      font-family: "Times New Roman", Times, serif;
      font-size: 1rem;
      color: #000;
      outline: none;
    }

    .chat-input:focus {
      border-bottom-color: #000;
    }

    .chat-send {
      background: none;
      border: none;
      font-family: "Times New Roman", Times, serif;
      font-size: 1rem;
      color: #000;
      cursor: pointer;
      text-decoration: underline;
      padding: 0;
    }

    .chat-send:hover {
      opacity: 0.5;
    }

    .chat-send:disabled {
      opacity: 0.3;
      cursor: default;
    }

    .typing {
      color: #999;
      font-style: italic;
    }

    .detector-controls {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      margin-bottom: 1rem;
    }

    .detector-layout {
      display: grid;
      grid-template-columns: minmax(0, 1fr) 260px;
      gap: 1.5rem;
      align-items: start;
    }

    #panel-detector {
      max-width: 980px;
    }

    .detector-stats {
      border-left: 1px solid #ddd;
      padding-left: 1rem;
      position: sticky;
      top: 1rem;
    }

    .detector-stats h2 {
      font-size: 1rem;
      margin-bottom: 0.7rem;
    }

    .detector-score-row {
      display: flex;
      justify-content: space-between;
      gap: 0.75rem;
      margin-bottom: 0.35rem;
      font-size: 0.95rem;
    }

    .detector-score-value {
      font-weight: bold;
    }

    .detector-calibration {
      margin-top: 0.7rem;
      color: #333;
      font-size: 0.9rem;
    }

    .detector-btn {
      background: none;
      border: 1px solid #ccc;
      font-family: "Times New Roman", Times, serif;
      font-size: 0.95rem;
      padding: 0.3rem 0.65rem;
      cursor: pointer;
      color: #000;
    }

    .detector-btn:hover {
      border-color: #000;
    }

    .detector-btn.subtle {
      color: #666;
      border-color: #ddd;
    }

    .detector-status {
      color: #333;
      margin-bottom: 0.75rem;
    }

    .detector-log {
      border-left: 1px solid #ddd;
      padding-left: 0.8rem;
      margin-bottom: 1rem;
      min-height: 120px;
    }

    .detector-line {
      margin-bottom: 0.8rem;
    }

    .detector-line .label {
      color: #888;
      font-style: italic;
      font-size: 0.85rem;
      margin-bottom: 0.2rem;
    }

    .detector-line.verdict .label {
      color: #000;
    }

    .detector-input-row {
      display: flex;
      gap: 0.75rem;
      align-items: flex-end;
    }

    .detector-input {
      flex: 1;
      padding: 0.5rem 0;
      background: none;
      border: none;
      border-bottom: 1px solid #ccc;
      font-family: "Times New Roman", Times, serif;
      font-size: 1rem;
      color: #000;
      outline: none;
    }

    .detector-input:focus {
      border-bottom-color: #000;
    }

    .is-hidden {
      display: none;
    }

    @media (max-width: 860px) {
      .experiments-layout {
        grid-template-columns: 1fr;
        gap: 1.25rem;
      }

      .experiments-menu {
        position: static;
        border-left: none;
        border-bottom: 1px solid #ddd;
        padding-left: 0;
        padding-bottom: 0.5rem;
      }

      .detector-layout {
        grid-template-columns: 1fr;
        gap: 1rem;
      }

      .detector-stats {
        position: static;
        border-left: none;
        border-top: 1px solid #ddd;
        padding-left: 0;
        padding-top: 0.8rem;
      }
    }
  </style>
</head>
<body>
  <nav>
    <a href="/">About</a>
    <a href="/worked-on.html">Things I have worked on</a>
    <a href="/working-on.html">Things I am working on</a>
    <a href="/artefacts.html">Artefacts</a>
    <a href="/experiments.html">Experiments</a>
  </nav>

  <div class="experiments-layout">
    <aside class="experiments-menu" aria-label="Experiment menu">
      <button class="experiment-tab active" data-panel="panel-chat" type="button">AI Me (chat)</button>
      <button class="experiment-tab" data-panel="panel-detector" type="button">AI detector</button>
      <button class="experiment-tab" data-panel="panel-fragments" type="button">Fragment combiner</button>
    </aside>

    <section class="experiments-content" id="experiments-content">
      <article class="experiment-panel active" id="panel-chat">
        <h1 class="experiment-title">AI Me (chat)</h1>
        <p class="experiment-description">This is an AI trained on my writing. Unsure what the point of this but here we are.</p>

        <div class="chat-container">
          <div class="chat-messages" id="messages"></div>

          <div class="chat-input-row">
            <input type="text" class="chat-input" id="input" placeholder="Ask something..." autocomplete="off">
            <button class="chat-send" id="send" type="button" onclick="sendMessage()">send</button>
          </div>
        </div>
      </article>

      <article class="experiment-panel" id="panel-detector">
        <h1 class="experiment-title">AI detector</h1>
        <p class="experiment-description">A chatbot interrogates the respondent and tries to guess: human or AI. You can play as yourself, or watch an AI play.</p>

        <div class="detector-layout">
          <div class="detector-main">
            <div class="detector-controls">
              <button class="detector-btn" id="play-human-btn" type="button">Play yourself</button>
              <button class="detector-btn" id="watch-ai-btn" type="button">Watch AI play</button>
              <button class="detector-btn subtle" id="reset-detector-btn" type="button">Reset</button>
            </div>

            <p class="detector-status" id="detector-status">Choose a mode to start.</p>
            <div class="detector-log" id="detector-log" aria-live="polite"></div>

            <div class="detector-input-row is-hidden" id="detector-input-row">
              <input type="text" class="detector-input" id="detector-input" placeholder="Type your answer..." autocomplete="off">
              <button class="chat-send" id="detector-send" type="button">send answer</button>
            </div>
          </div>

          <aside class="detector-stats" aria-label="All-time scoreboard">
            <h2>All-time scoreboard</h2>
            <div class="detector-score-row"><span>Total rounds</span><span class="detector-score-value" id="score-total">0</span></div>
            <div class="detector-score-row"><span>AI got it right</span><span class="detector-score-value" id="score-right">0</span></div>
            <div class="detector-score-row"><span>AI got it wrong</span><span class="detector-score-value" id="score-wrong">0</span></div>
            <div class="detector-score-row"><span>True humans</span><span class="detector-score-value" id="score-human-rounds">0</span></div>
            <div class="detector-score-row"><span>True AIs</span><span class="detector-score-value" id="score-ai-rounds">0</span></div>
            <p class="detector-calibration" id="score-calibration">Calibration score: -</p>
          </aside>
        </div>
      </article>

      <article class="experiment-panel" id="panel-fragments">
        <h1 class="experiment-title">Fragment combiner</h1>
        <p class="experiment-description">An experiment for merging short written fragments into longer essays. This is currently in progress.</p>
      </article>
    </section>
  </div>

  <script>
    const tabs = document.querySelectorAll(".experiment-tab");
    const panels = document.querySelectorAll(".experiment-panel");

    tabs.forEach((tab) => {
      tab.addEventListener("click", () => {
        tabs.forEach((t) => t.classList.remove("active"));
        panels.forEach((p) => p.classList.remove("active"));

        tab.classList.add("active");
        const panel = document.getElementById(tab.dataset.panel);
        if (panel) panel.classList.add("active");
      });
    });

    const WORKER_URL = "https://stefan-chatbot.stefankelly.workers.dev";
    const messagesEl = document.getElementById("messages");
    const inputEl = document.getElementById("input");
    const sendBtn = document.getElementById("send");
    const chatPanel = document.getElementById("panel-chat");
    let history = [];

    if (inputEl && sendBtn) {
      inputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !sendBtn.disabled) sendMessage();
      });
    }

    async function sendMessage() {
      if (!inputEl || !sendBtn || !messagesEl || !chatPanel.classList.contains("active")) return;

      const text = inputEl.value.trim();
      if (!text) return;

      inputEl.value = "";
      sendBtn.disabled = true;

      history.push({ role: "user", content: text });
      appendMessage("you", text);
      appendMessage("typing", "thinking...");

      try {
        const res = await fetch(WORKER_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ messages: history }),
        });

        const data = await res.json();
        removeTyping();

        if (data.content && data.content[0]) {
          const reply = data.content[0].text;
          history.push({ role: "assistant", content: reply });
          appendMessage("stefan", reply);
        } else {
          appendMessage("stefan", "Sorry, something went wrong.");
        }
      } catch (e) {
        removeTyping();
        appendMessage("stefan", "Sorry, couldn't reach the server.");
      }

      sendBtn.disabled = false;
      inputEl.focus();
    }

    function appendMessage(sender, text) {
      const div = document.createElement("div");
      div.className = sender === "typing" ? "chat-message typing" : "chat-message " + (sender === "you" ? "user" : "assistant");
      if (sender === "typing") {
        div.id = "typing";
        div.textContent = text;
      } else {
        div.innerHTML = `<div class="label">${sender}</div><div>${text}</div>`;
      }
      messagesEl.appendChild(div);
      window.scrollTo(0, document.body.scrollHeight);
    }

    function removeTyping() {
      const t = document.getElementById("typing");
      if (t) t.remove();
    }

    const detectorPanel = document.getElementById("panel-detector");
    const detectorLogEl = document.getElementById("detector-log");
    const detectorStatusEl = document.getElementById("detector-status");
    const detectorInputRow = document.getElementById("detector-input-row");
    const detectorInput = document.getElementById("detector-input");
    const detectorSend = document.getElementById("detector-send");
    const playHumanBtn = document.getElementById("play-human-btn");
    const watchAiBtn = document.getElementById("watch-ai-btn");
    const resetDetectorBtn = document.getElementById("reset-detector-btn");
    const scoreTotalEl = document.getElementById("score-total");
    const scoreRightEl = document.getElementById("score-right");
    const scoreWrongEl = document.getElementById("score-wrong");
    const scoreHumanRoundsEl = document.getElementById("score-human-rounds");
    const scoreAiRoundsEl = document.getElementById("score-ai-rounds");
    const scoreCalibrationEl = document.getElementById("score-calibration");

    const detectorQuestions = [
      "What did you do in the last hour?",
      "What is one opinion you have that most people around you disagree with?",
      "Tell me about a mistake you made recently.",
      "Describe something mundane in a way only you would."
    ];
    const DETECTOR_STATS_KEY = "ai_detector_scoreboard_v1";

    const detectorState = {
      mode: null,
      step: 0,
      answers: [],
      watching: false,
      busy: false,
      watchHistory: []
    };
    let detectorStats = loadDetectorStats();

    if (playHumanBtn) playHumanBtn.addEventListener("click", startHumanGame);
    if (watchAiBtn) watchAiBtn.addEventListener("click", startWatchGame);
    if (resetDetectorBtn) resetDetectorBtn.addEventListener("click", resetDetector);
    if (detectorSend) detectorSend.addEventListener("click", submitHumanAnswer);
    if (detectorInput) {
      detectorInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") submitHumanAnswer();
      });
    }
    renderScoreboard();

    function defaultDetectorStats() {
      return {
        totalRounds: 0,
        correct: 0,
        wrong: 0,
        humanRounds: 0,
        aiRounds: 0,
        brierSum: 0
      };
    }

    function loadDetectorStats() {
      try {
        const raw = localStorage.getItem(DETECTOR_STATS_KEY);
        if (!raw) return defaultDetectorStats();
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object") return defaultDetectorStats();
        return {
          totalRounds: Number(parsed.totalRounds) || 0,
          correct: Number(parsed.correct) || 0,
          wrong: Number(parsed.wrong) || 0,
          humanRounds: Number(parsed.humanRounds) || 0,
          aiRounds: Number(parsed.aiRounds) || 0,
          brierSum: Number(parsed.brierSum) || 0
        };
      } catch (e) {
        return defaultDetectorStats();
      }
    }

    function saveDetectorStats() {
      try {
        localStorage.setItem(DETECTOR_STATS_KEY, JSON.stringify(detectorStats));
      } catch (e) {}
    }

    function getCalibrationScore() {
      if (!detectorStats.totalRounds) return "-";
      const avgBrier = detectorStats.brierSum / detectorStats.totalRounds;
      const calibration = Math.max(0, Math.min(100, Math.round((1 - avgBrier) * 100)));
      return `${calibration}/100`;
    }

    function renderScoreboard() {
      if (scoreTotalEl) scoreTotalEl.textContent = String(detectorStats.totalRounds);
      if (scoreRightEl) scoreRightEl.textContent = String(detectorStats.correct);
      if (scoreWrongEl) scoreWrongEl.textContent = String(detectorStats.wrong);
      if (scoreHumanRoundsEl) scoreHumanRoundsEl.textContent = String(detectorStats.humanRounds);
      if (scoreAiRoundsEl) scoreAiRoundsEl.textContent = String(detectorStats.aiRounds);
      if (scoreCalibrationEl) scoreCalibrationEl.textContent = `Calibration score: ${getCalibrationScore()}`;
    }

    function setDetectorStatus(text) {
      if (detectorStatusEl) detectorStatusEl.textContent = text;
    }

    function setDetectorControlsDisabled(disabled) {
      detectorState.busy = disabled;
      if (playHumanBtn) playHumanBtn.disabled = disabled;
      if (watchAiBtn) watchAiBtn.disabled = disabled;
      if (detectorSend) detectorSend.disabled = disabled;
    }

    function appendDetectorLine(label, text, isVerdict) {
      if (!detectorLogEl) return;
      const row = document.createElement("div");
      row.className = isVerdict ? "detector-line verdict" : "detector-line";
      row.innerHTML = `<div class="label">${label}</div><div>${text}</div>`;
      detectorLogEl.appendChild(row);
      detectorLogEl.scrollTop = detectorLogEl.scrollHeight;
    }

    function resetDetector() {
      detectorState.mode = null;
      detectorState.step = 0;
      detectorState.answers = [];
      detectorState.watching = false;
      detectorState.busy = false;
      detectorState.watchHistory = [];
      if (detectorLogEl) detectorLogEl.innerHTML = "";
      if (detectorInputRow) detectorInputRow.classList.add("is-hidden");
      if (detectorInput) detectorInput.value = "";
      if (playHumanBtn) playHumanBtn.disabled = false;
      if (watchAiBtn) watchAiBtn.disabled = false;
      if (detectorSend) detectorSend.disabled = false;
      setDetectorStatus("Choose a mode to start.");
    }

    function askNextQuestion() {
      const q = detectorQuestions[detectorState.step];
      if (q) appendDetectorLine("interrogator", q, false);
    }

    function startHumanGame() {
      resetDetector();
      detectorState.mode = "human";
      setDetectorStatus("Mode: Play yourself. Answer all 4 questions.");
      if (detectorInputRow) detectorInputRow.classList.remove("is-hidden");
      askNextQuestion();
      if (detectorInput) detectorInput.focus();
    }

    async function submitHumanAnswer() {
      if (detectorState.mode !== "human" || detectorState.busy || !detectorInput || !detectorPanel.classList.contains("active")) return;
      const text = detectorInput.value.trim();
      if (!text) return;

      appendDetectorLine("you", text, false);
      detectorState.answers.push(text);
      detectorInput.value = "";
      detectorState.step += 1;

      if (detectorState.step < detectorQuestions.length) {
        askNextQuestion();
        detectorInput.focus();
      } else {
        await endRound(detectorState.answers);
      }
    }

    async function startWatchGame() {
      resetDetector();
      detectorState.mode = "watch";
      detectorState.watching = true;
      setDetectorControlsDisabled(true);
      setDetectorStatus("Mode: Watch AI play. Running two-model simulation...");

      try {
        const payload = await callWorkerPath("/detector/watch", { questions: detectorQuestions });
        const transcript = Array.isArray(payload.transcript) ? payload.transcript : [];
        const verdict = payload && payload.verdict ? payload.verdict : null;
        const meta = payload && payload.meta ? payload.meta : null;

        if (!transcript.length || !verdict) {
          throw new Error("Missing transcript or verdict in detector watch response.");
        }

        transcript.forEach((line) => {
          const label = line.role === "respondent" ? "respondent" : "interrogator";
          appendDetectorLine(label, line.text || "", false);
        });

        const normalVerdict = {
          guess: verdict.guess === "AI" ? "AI" : "Human",
          confidence: Number.isFinite(verdict.confidence) ? Math.max(50, Math.min(99, Math.round(verdict.confidence))) : 70,
          reason: typeof verdict.reason === "string" && verdict.reason.trim() ? verdict.reason.trim() : "Classified from conversation patterns."
        };

        const correct = recordRound(normalVerdict, "AI");
        setDetectorStatus(`Verdict: ${normalVerdict.guess} (${normalVerdict.confidence}% confidence)`);
        appendDetectorLine("verdict", `I think this respondent is ${normalVerdict.guess.toLowerCase()} (${normalVerdict.confidence}% confidence). ${normalVerdict.reason}`, true);
        appendDetectorLine("result", `Ground truth: AI. AI got it ${correct ? "right" : "wrong"}.`, true);
        if (meta && meta.interrogator_model && meta.respondent_model) {
          appendDetectorLine("models", `Interrogator: ${meta.interrogator_model}. Respondent: ${meta.respondent_model}.`, true);
        }
      } catch (e) {
        setDetectorStatus("Could not run watch mode right now.");
        appendDetectorLine("error", "Worker request failed. Check worker deploy/keys and try again.", true);
      }

      detectorState.watching = false;
      setDetectorControlsDisabled(false);
    }

    function recordRound(verdict, groundTruth) {
      const correct = verdict.guess === groundTruth;
      const numericConfidence = Number.isFinite(verdict.confidence) ? verdict.confidence : 70;
      const confidence = Math.max(0.5, Math.min(0.99, numericConfidence / 100));
      const pAi = verdict.guess === "AI" ? confidence : 1 - confidence;
      const yAi = groundTruth === "AI" ? 1 : 0;
      const brier = Math.pow(pAi - yAi, 2);

      detectorStats.totalRounds += 1;
      detectorStats.correct += correct ? 1 : 0;
      detectorStats.wrong += correct ? 0 : 1;
      detectorStats.humanRounds += groundTruth === "Human" ? 1 : 0;
      detectorStats.aiRounds += groundTruth === "AI" ? 1 : 0;
      detectorStats.brierSum += brier;
      saveDetectorStats();
      renderScoreboard();
      return correct;
    }

    async function endRound(answers) {
      detectorState.watching = false;
      setDetectorControlsDisabled(true);
      if (detectorInputRow) detectorInputRow.classList.add("is-hidden");
      setDetectorStatus("Evaluating transcript...");

      const verdict = await getVerdict(answers);
      const groundTruth = detectorState.mode === "watch" ? "AI" : "Human";
      const correct = recordRound(verdict, groundTruth);

      setDetectorStatus(`Verdict: ${verdict.guess} (${verdict.confidence}% confidence)`);
      appendDetectorLine("verdict", `I think this respondent is ${verdict.guess.toLowerCase()} (${verdict.confidence}% confidence). ${verdict.reason}`, true);
      appendDetectorLine("result", `Ground truth: ${groundTruth}. AI got it ${correct ? "right" : "wrong"}.`, true);
      setDetectorControlsDisabled(false);
    }

    async function callWorkerPath(path, payload) {
      const res = await fetch(`${WORKER_URL}${path}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload || {})
      });
      const data = await res.json();
      if (!res.ok) {
        const msg = data && data.message ? data.message : `HTTP ${res.status}`;
        throw new Error(msg);
      }
      return data;
    }

    function parseVerdictJson(raw) {
      const cleaned = String(raw || "")
        .replace(/```json/gi, "")
        .replace(/```/g, "")
        .trim();

      try {
        const direct = JSON.parse(cleaned);
        if (direct && direct.guess) return direct;
      } catch (e) {}

      const match = cleaned.match(/\{[\s\S]*\}/);
      if (!match) return null;
      try {
        const parsed = JSON.parse(match[0]);
        return parsed && parsed.guess ? parsed : null;
      } catch (e) {
        const guessMatch = cleaned.match(/\b(ai|human)\b/i);
        const confMatch = cleaned.match(/(\d{2,3})\s*%?/);
        const reasonMatch = cleaned.match(/reason[:\-]\s*(.+)$/im);
        if (!guessMatch) return null;
        return {
          guess: guessMatch[1].toUpperCase() === "AI" ? "AI" : "Human",
          confidence: confMatch ? Number(confMatch[1]) : 70,
          reason: reasonMatch ? reasonMatch[1].trim() : "Based on language cues in the responses."
        };
      }
    }

    async function getVerdict(answers) {
      try {
        const payload = await callWorkerPath("/detector/verdict", {
          questions: detectorQuestions,
          answers
        });
        if (payload && payload.verdict) {
          const v = payload.verdict;
          const guess = v.guess === "AI" ? "AI" : "Human";
          const confidence = Number.isFinite(v.confidence) ? Math.max(50, Math.min(99, Math.round(v.confidence))) : 70;
          const reason = typeof v.reason === "string" && v.reason.trim() ? v.reason.trim() : "The linguistic pattern suggested this classification.";
          return { guess, confidence, reason };
        }
      } catch (e) {
        // Fallback to previous root endpoint behavior if worker routes are not deployed yet.
      }

      const transcript = detectorQuestions.map((question, index) => {
        const answer = answers[index] || "";
        return `${index + 1}. Q: ${question}\nA: ${answer}`;
      }).join("\n\n");

      const systemPrompt = "You are an interrogator classifying whether a respondent is AI or human from short answers. Output one single-line JSON object only, no markdown, no extra text. Keys: guess, confidence, reason. guess must be AI or Human. confidence must be integer 50-99. reason must be one sentence.";
      const userPrompt = `Classify this transcript:\n\n${transcript}`;

      try {
        const legacy = await callWorkerPath("", {
          messages: [
            { role: "system", content: systemPrompt },
            { role: "user", content: userPrompt }
          ]
        });
        const text = legacy && legacy.content && legacy.content[0] ? legacy.content[0].text : "";
        const parsed = parseVerdictJson(text || "");
        if (parsed) {
          const guess = parsed.guess === "AI" ? "AI" : "Human";
          const confidence = Number.isFinite(parsed.confidence) ? Math.max(50, Math.min(99, Math.round(parsed.confidence))) : 70;
          const reason = typeof parsed.reason === "string" && parsed.reason.trim() ? parsed.reason.trim() : "The linguistic pattern suggested this classification.";
          return { guess, confidence, reason };
        }
      } catch (e) {}

      return {
        guess: "Human",
        confidence: 65,
        reason: "Could not confidently parse the model output, so this is a safe default."
      };
    }
  </script>
</body>
</html>
