<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Experiments â€” Stefan Kelly</title>
  <link rel="stylesheet" href="styles.css">
  <style>
    .experiments-layout {
      display: grid;
      grid-template-columns: 230px minmax(0, 1fr);
      gap: 2rem;
      align-items: start;
    }

    .experiments-menu {
      position: sticky;
      top: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      border-left: 1px solid #ddd;
      padding-left: 1rem;
    }

    .experiment-tab {
      background: none;
      border: none;
      text-align: left;
      font-family: "Times New Roman", Times, serif;
      font-size: 0.95rem;
      color: #999;
      cursor: pointer;
      padding: 0.1rem 0;
    }

    .experiment-tab:hover,
    .experiment-tab:focus-visible {
      color: #000;
      outline: none;
    }

    .experiment-tab.active {
      color: #000;
      text-decoration: underline;
    }

    .experiments-content {
      min-height: 320px;
      position: relative;
      overflow: visible;
    }

    .experiment-panel {
      display: none;
      max-width: 680px;
      animation: slide-in 220ms ease-out;
    }

    .experiment-panel.active {
      display: block;
    }

    @keyframes slide-in {
      from {
        opacity: 0;
        transform: translateX(14px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .experiment-title {
      margin-bottom: 0.4rem;
      font-size: 1.2rem;
    }

    .experiment-description {
      margin-bottom: 1.25rem;
      color: #333;
      max-width: 60ch;
    }

    .chat-container {
      max-width: 600px;
    }

    .chat-messages {
      margin-bottom: 1.5rem;
      min-height: 2rem;
    }

    .chat-message {
      margin-bottom: 1.25rem;
    }

    .chat-message.user {
      color: #999;
    }

    .chat-message.assistant {
      color: #000;
    }

    .chat-message .label {
      font-style: italic;
      font-size: 0.85rem;
      margin-bottom: 0.25rem;
    }

    .chat-input-row {
      display: flex;
      gap: 0.75rem;
      align-items: flex-end;
    }

    .chat-input {
      flex: 1;
      padding: 0.5rem 0;
      background: none;
      border: none;
      border-bottom: 1px solid #ccc;
      font-family: "Times New Roman", Times, serif;
      font-size: 1rem;
      color: #000;
      outline: none;
    }

    .chat-input:focus {
      border-bottom-color: #000;
    }

    .chat-send {
      background: none;
      border: none;
      font-family: "Times New Roman", Times, serif;
      font-size: 1rem;
      color: #000;
      cursor: pointer;
      text-decoration: underline;
      padding: 0;
    }

    .chat-send:hover {
      opacity: 0.5;
    }

    .chat-send:disabled {
      opacity: 0.3;
      cursor: default;
    }

    .typing {
      color: #999;
      font-style: italic;
    }

    .detector-controls {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      margin-bottom: 1rem;
    }

    .detector-layout {
      display: grid;
      grid-template-columns: minmax(520px, 1fr) 540px;
      gap: 1.5rem;
      align-items: start;
    }

    body.experiments-page {
      max-width: 1500px;
    }

    #panel-detector {
      max-width: 980px;
    }

    .detector-stats-wrap {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      align-items: start;
    }

    .detector-stats {
      border-left: 1px solid #ddd;
      padding-left: 1rem;
      position: sticky;
      top: 1rem;
    }

    .detector-stats h2 {
      font-size: 1rem;
      margin-bottom: 0.7rem;
    }

    .detector-score-row {
      display: flex;
      justify-content: space-between;
      gap: 0.75rem;
      margin-bottom: 0.35rem;
      font-size: 0.95rem;
    }

    .detector-score-value {
      font-weight: bold;
    }

    .detector-calibration {
      margin-top: 0.7rem;
      color: #333;
      font-size: 0.9rem;
    }

    .detector-info {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 1rem;
      height: 1rem;
      border: 1px solid #bbb;
      border-radius: 50%;
      font-size: 0.7rem;
      line-height: 1;
      color: #666;
      margin-left: 0.3rem;
      cursor: default;
      position: relative;
      vertical-align: middle;
      user-select: none;
    }

    .detector-tooltip {
      position: absolute;
      left: 50%;
      top: calc(100% + 0.35rem);
      transform: translateX(-50%);
      width: 220px;
      padding: 0.45rem 0.55rem;
      background: #fff;
      border: 1px solid #ddd;
      color: #333;
      font-size: 0.75rem;
      line-height: 1.35;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.06);
      display: none;
      z-index: 20;
    }

    .detector-info:hover .detector-tooltip,
    .detector-info:focus-visible .detector-tooltip {
      display: block;
    }

    .detector-btn {
      background: none;
      border: 1px solid #ccc;
      font-family: "Times New Roman", Times, serif;
      font-size: 0.95rem;
      padding: 0.3rem 0.65rem;
      cursor: pointer;
      color: #000;
    }

    .detector-btn:hover {
      border-color: #000;
    }

    .detector-btn.subtle {
      color: #666;
      border-color: #ddd;
    }

    .detector-status {
      color: #333;
      margin-bottom: 0.75rem;
    }

    .detector-log {
      border-left: 1px solid #ddd;
      padding-left: 0.8rem;
      margin-bottom: 1rem;
      min-height: 120px;
    }

    .detector-line {
      margin-bottom: 0.8rem;
    }

    .detector-line .label {
      color: #888;
      font-style: italic;
      font-size: 0.85rem;
      margin-bottom: 0.2rem;
    }

    .detector-line.verdict .label {
      color: #000;
    }

    .detector-input-row {
      display: flex;
      gap: 0.75rem;
      align-items: flex-end;
    }

    .detector-input {
      flex: 1;
      padding: 0.5rem 0;
      background: none;
      border: none;
      border-bottom: 1px solid #ccc;
      font-family: "Times New Roman", Times, serif;
      font-size: 1rem;
      color: #000;
      outline: none;
    }

    .detector-input:focus {
      border-bottom-color: #000;
    }

    .is-hidden {
      display: none;
    }

    .traitors-wrap {
      display: grid;
      grid-template-columns: minmax(0, 1fr) 300px;
      gap: 1.2rem;
      align-items: start;
    }

    .traitors-scene {
      border: 1px solid #ddd;
      padding: 0.8rem;
      margin-bottom: 0.9rem;
      background: linear-gradient(to bottom, #fafafa 0%, #f3f3f3 100%);
    }

    .roundtable-scene {
      position: relative;
      height: 260px;
      border: 1px solid #e1e1e1;
      background: #fff;
      overflow: hidden;
    }

    .roundtable-table {
      position: absolute;
      width: 170px;
      height: 170px;
      border: 2px solid #ccc;
      border-radius: 50%;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background: radial-gradient(circle at 35% 30%, #f4f4f4 0%, #e9e9e9 75%);
    }

    .traitors-seat {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: rotate(var(--angle)) translateY(calc(-1 * var(--radius))) rotate(calc(-1 * var(--angle)));
      padding: 0.22rem 0.45rem;
      border: 1px solid #ccc;
      background: #fff;
      font-size: 0.82rem;
      white-space: nowrap;
    }

    .traitors-seat.human {
      border-color: #000;
      font-weight: bold;
    }

    .traitors-seat.dead {
      opacity: 0.45;
      text-decoration: line-through;
    }

    .traitors-log {
      border-left: 1px solid #ddd;
      padding-left: 0.75rem;
      min-height: 170px;
      max-height: 410px;
      overflow: auto;
      margin-bottom: 0.8rem;
    }

    .traitors-line {
      margin-bottom: 0.75rem;
    }

    .traitors-line .label {
      color: #888;
      font-style: italic;
      font-size: 0.82rem;
      margin-bottom: 0.2rem;
    }

    .traitors-controls {
      display: flex;
      flex-direction: column;
      gap: 0.55rem;
    }

    .traitors-select {
      width: 100%;
      font-family: "Times New Roman", Times, serif;
      font-size: 0.95rem;
      border: 1px solid #ccc;
      background: #fff;
      padding: 0.35rem 0.45rem;
    }

    .traitors-input {
      width: 100%;
      min-height: 78px;
      border: 1px solid #ccc;
      padding: 0.45rem;
      font-family: "Times New Roman", Times, serif;
      font-size: 0.95rem;
      resize: vertical;
    }

    @media (max-width: 860px) {
      .experiments-layout {
        grid-template-columns: 1fr;
        gap: 1.25rem;
      }

      .experiments-menu {
        position: static;
        border-left: none;
        border-bottom: 1px solid #ddd;
        padding-left: 0;
        padding-bottom: 0.5rem;
      }

      .detector-layout {
        grid-template-columns: 1fr;
        gap: 1rem;
      }

      .traitors-wrap {
        grid-template-columns: 1fr;
      }

      .detector-stats-wrap {
        grid-template-columns: 1fr;
        gap: 0.75rem;
      }

      .detector-stats {
        position: static;
        border-left: none;
        border-top: 1px solid #ddd;
        padding-left: 0;
        padding-top: 0.8rem;
      }
    }
  </style>
</head>
<body class="experiments-page">
  <nav>
    <a href="/">About</a>
    <a href="/worked-on.html">Things I have worked on</a>
    <a href="/working-on.html">Things I am working on</a>
    <a href="/artefacts.html">Artefacts</a>
    <a href="/experiments.html">Experiments</a>
  </nav>

  <div class="experiments-layout">
    <aside class="experiments-menu" aria-label="Experiment menu">
      <button class="experiment-tab active" data-panel="panel-detector" type="button">AI Detector</button>
      <button class="experiment-tab" data-panel="panel-traitors" type="button">The Traitors</button>
      <button class="experiment-tab" data-panel="panel-chat" type="button">AI Me (chat)</button>
    </aside>

    <section class="experiments-content" id="experiments-content">
      <article class="experiment-panel" id="panel-chat">
        <h1 class="experiment-title">AI Me (chat)</h1>
        <p class="experiment-description">This is an AI trained on my writing.<br>Unsure what the point of this is, but here we are.</p>

        <div class="chat-container">
          <div class="chat-messages" id="messages"></div>

          <div class="chat-input-row">
            <input type="text" class="chat-input" id="input" placeholder="Ask something..." autocomplete="off">
            <button class="chat-send" id="send" type="button" onclick="sendMessage()">send</button>
          </div>
        </div>
      </article>

      <article class="experiment-panel" id="panel-traitors">
        <h1 class="experiment-title">The Traitors (AI Edition)</h1>
        <p class="experiment-description">You are the Traitor. Survive to final three to win.<br>The AI Faithful win if they banish you first.</p>

        <div class="traitors-wrap">
          <div>
            <div class="traitors-scene">
              <div class="roundtable-scene" id="traitors-scene">
                <div class="roundtable-table"></div>
              </div>
            </div>

            <div class="traitors-log" id="traitors-log"></div>
          </div>

          <div class="traitors-controls">
            <button class="detector-btn" id="traitors-start-btn" type="button">Start game</button>
            <button class="detector-btn subtle" id="traitors-reset-btn" type="button">Reset game</button>

            <label for="traitors-statement">Your banishment pitch</label>
            <textarea class="traitors-input" id="traitors-statement" placeholder="Defend yourself. Throw suspicion elsewhere."></textarea>

            <label for="traitors-vote">Your banishment vote</label>
            <select class="traitors-select" id="traitors-vote"></select>
            <button class="detector-btn" id="traitors-banish-btn" type="button">Run banishment</button>

            <label for="traitors-murder">Night murder target</label>
            <select class="traitors-select" id="traitors-murder"></select>
            <button class="detector-btn" id="traitors-night-btn" type="button">Run night</button>
          </div>
        </div>
      </article>

      <article class="experiment-panel active" id="panel-detector">
        <h1 class="experiment-title">AI Detector</h1>
        <p class="experiment-description">A chatbot interrogates the respondent and tries to guess: human or AI.<br>You can play as yourself, or watch an AI play.</p>

        <div class="detector-layout">
          <div class="detector-main">
            <div class="detector-controls">
              <button class="detector-btn" id="play-human-btn" type="button">Play yourself</button>
              <button class="detector-btn" id="watch-ai-btn" type="button">Watch AI play</button>
              <button class="detector-btn subtle" id="reset-detector-btn" type="button">Reset</button>
            </div>

            <p class="detector-status" id="detector-status">Choose a mode to start.</p>
            <div class="detector-log" id="detector-log" aria-live="polite"></div>

            <div class="detector-input-row is-hidden" id="detector-input-row">
              <input type="text" class="detector-input" id="detector-input" placeholder="Type your answer..." autocomplete="off">
              <button class="chat-send" id="detector-send" type="button">send answer</button>
            </div>
          </div>

          <div class="detector-stats-wrap">
            <aside class="detector-stats" aria-label="All-time scoreboard">
              <h2>All-time scoreboard</h2>
              <div class="detector-score-row"><span>Total rounds</span><span class="detector-score-value" id="score-total">0</span></div>
              <div class="detector-score-row"><span>AI got it right</span><span class="detector-score-value" id="score-right">0</span></div>
              <div class="detector-score-row"><span>AI got it wrong</span><span class="detector-score-value" id="score-wrong">0</span></div>
              <div class="detector-score-row"><span>True humans</span><span class="detector-score-value" id="score-human-rounds">0</span></div>
              <div class="detector-score-row"><span>True AIs</span><span class="detector-score-value" id="score-ai-rounds">0</span></div>
              <p class="detector-calibration">
                Brier score
                <span class="detector-info" tabindex="0" aria-label="What is Brier score?">
                  i
                  <span class="detector-tooltip">Mean squared error of confidence vs outcome. Lower is better. 0 is perfect.</span>
                </span>
                : <span id="score-calibration-value">-</span>
              </p>
            </aside>

            <aside class="detector-stats" aria-label="Session scoreboard">
              <h2>Session scoreboard</h2>
              <div class="detector-score-row"><span>Total rounds</span><span class="detector-score-value" id="session-score-total">0</span></div>
              <div class="detector-score-row"><span>AI got it right</span><span class="detector-score-value" id="session-score-right">0</span></div>
              <div class="detector-score-row"><span>AI got it wrong</span><span class="detector-score-value" id="session-score-wrong">0</span></div>
              <div class="detector-score-row"><span>True humans</span><span class="detector-score-value" id="session-score-human-rounds">0</span></div>
              <div class="detector-score-row"><span>True AIs</span><span class="detector-score-value" id="session-score-ai-rounds">0</span></div>
              <p class="detector-calibration">Brier score: <span id="session-score-calibration-value">-</span></p>
            </aside>
          </div>
        </div>
      </article>

    </section>
  </div>

  <script>
    const tabs = document.querySelectorAll(".experiment-tab");
    const panels = document.querySelectorAll(".experiment-panel");

    tabs.forEach((tab) => {
      tab.addEventListener("click", () => {
        tabs.forEach((t) => t.classList.remove("active"));
        panels.forEach((p) => p.classList.remove("active"));

        tab.classList.add("active");
        const panel = document.getElementById(tab.dataset.panel);
        if (panel) panel.classList.add("active");
      });
    });

    const WORKER_URL = "https://stefan-chatbot.stefankelly.workers.dev";
    const messagesEl = document.getElementById("messages");
    const inputEl = document.getElementById("input");
    const sendBtn = document.getElementById("send");
    const chatPanel = document.getElementById("panel-chat");
    let history = [];

    if (inputEl && sendBtn) {
      inputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !sendBtn.disabled) sendMessage();
      });
    }

    async function sendMessage() {
      if (!inputEl || !sendBtn || !messagesEl || !chatPanel.classList.contains("active")) return;

      const text = inputEl.value.trim();
      if (!text) return;

      inputEl.value = "";
      sendBtn.disabled = true;

      history.push({ role: "user", content: text });
      appendMessage("you", text);
      appendMessage("typing", "thinking...");

      try {
        const res = await fetch(WORKER_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ messages: history }),
        });

        const data = await res.json();
        removeTyping();

        if (data.content && data.content[0]) {
          const reply = data.content[0].text;
          history.push({ role: "assistant", content: reply });
          appendMessage("stefan", reply);
        } else {
          appendMessage("stefan", "Sorry, something went wrong.");
        }
      } catch (e) {
        removeTyping();
        appendMessage("stefan", "Sorry, couldn't reach the server.");
      }

      sendBtn.disabled = false;
      inputEl.focus();
    }

    function appendMessage(sender, text) {
      const div = document.createElement("div");
      div.className = sender === "typing" ? "chat-message typing" : "chat-message " + (sender === "you" ? "user" : "assistant");
      if (sender === "typing") {
        div.id = "typing";
        div.textContent = text;
      } else {
        div.innerHTML = `<div class="label">${sender}</div><div>${text}</div>`;
      }
      messagesEl.appendChild(div);
      window.scrollTo(0, document.body.scrollHeight);
    }

    function removeTyping() {
      const t = document.getElementById("typing");
      if (t) t.remove();
    }

    const detectorPanel = document.getElementById("panel-detector");
    const detectorLogEl = document.getElementById("detector-log");
    const detectorStatusEl = document.getElementById("detector-status");
    const detectorInputRow = document.getElementById("detector-input-row");
    const detectorInput = document.getElementById("detector-input");
    const detectorSend = document.getElementById("detector-send");
    const playHumanBtn = document.getElementById("play-human-btn");
    const watchAiBtn = document.getElementById("watch-ai-btn");
    const resetDetectorBtn = document.getElementById("reset-detector-btn");
    const scoreTotalEl = document.getElementById("score-total");
    const scoreRightEl = document.getElementById("score-right");
    const scoreWrongEl = document.getElementById("score-wrong");
    const scoreHumanRoundsEl = document.getElementById("score-human-rounds");
    const scoreAiRoundsEl = document.getElementById("score-ai-rounds");
    const scoreCalibrationValueEl = document.getElementById("score-calibration-value");
    const sessionScoreTotalEl = document.getElementById("session-score-total");
    const sessionScoreRightEl = document.getElementById("session-score-right");
    const sessionScoreWrongEl = document.getElementById("session-score-wrong");
    const sessionScoreHumanRoundsEl = document.getElementById("session-score-human-rounds");
    const sessionScoreAiRoundsEl = document.getElementById("session-score-ai-rounds");
    const sessionScoreCalibrationValueEl = document.getElementById("session-score-calibration-value");
    const traitorsSceneEl = document.getElementById("traitors-scene");
    const traitorsLogEl = document.getElementById("traitors-log");
    const traitorsStartBtn = document.getElementById("traitors-start-btn");
    const traitorsResetBtn = document.getElementById("traitors-reset-btn");
    const traitorsStatementEl = document.getElementById("traitors-statement");
    const traitorsVoteEl = document.getElementById("traitors-vote");
    const traitorsBanishBtn = document.getElementById("traitors-banish-btn");
    const traitorsMurderEl = document.getElementById("traitors-murder");
    const traitorsNightBtn = document.getElementById("traitors-night-btn");

    const detectorQuestionPool = [
      "What did your morning look like today?",
      "What is something small that annoyed you this week?",
      "What is one opinion you have that most people around you disagree with?",
      "Describe something mundane in a way only you would.",
      "What is a habit you have that other people find odd?",
      "Tell me about a time you changed your mind about something important.",
      "What is one detail about your local area that outsiders miss?",
      "What do you usually overthink for no good reason?"
    ];

    const detectorState = {
      mode: null,
      step: 0,
      answers: [],
      watching: false,
      busy: false,
      watchHistory: [],
      playHistory: [],
      currentQuestion: "",
      questions: [],
      playInterrogatorMeta: "",
      watchInterrogatorMeta: "",
      watchRespondentMeta: ""
    };
    let detectorStats = defaultDetectorStats();
    let sessionDetectorStats = defaultDetectorStats();
    let traitorsState = null;
    let traitorsBusy = false;

    if (playHumanBtn) playHumanBtn.addEventListener("click", startHumanGame);
    if (watchAiBtn) watchAiBtn.addEventListener("click", startWatchGame);
    if (resetDetectorBtn) resetDetectorBtn.addEventListener("click", resetDetector);
    if (detectorSend) detectorSend.addEventListener("click", submitHumanAnswer);
    if (detectorInput) {
      detectorInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") submitHumanAnswer();
      });
    }
    if (traitorsStartBtn) traitorsStartBtn.addEventListener("click", startTraitorsGame);
    if (traitorsResetBtn) traitorsResetBtn.addEventListener("click", resetTraitorsGame);
    if (traitorsBanishBtn) traitorsBanishBtn.addEventListener("click", runTraitorsBanishment);
    if (traitorsNightBtn) traitorsNightBtn.addEventListener("click", runTraitorsNight);
    renderScoreboard();
    refreshGlobalScoreboard();

    function defaultDetectorStats() {
      return {
        totalRounds: 0,
        correct: 0,
        wrong: 0,
        humanRounds: 0,
        aiRounds: 0,
        brierSum: 0
      };
    }

    function normalizeStats(raw) {
      return {
        totalRounds: Number(raw && raw.totalRounds) || 0,
        correct: Number(raw && raw.correct) || 0,
        wrong: Number(raw && raw.wrong) || 0,
        humanRounds: Number(raw && raw.humanRounds) || 0,
        aiRounds: Number(raw && raw.aiRounds) || 0,
        brierSum: Number(raw && raw.brierSum) || 0
      };
    }

    async function refreshGlobalScoreboard() {
      try {
        const payload = await callWorkerPath("/detector/stats/get", {});
        if (payload && payload.stats) {
          detectorStats = normalizeStats(payload.stats);
          renderScoreboard();
        }
      } catch (e) {}
    }

    function getBrierScore(stats) {
      if (!stats.totalRounds) return "-";
      const avgBrier = stats.brierSum / stats.totalRounds;
      return avgBrier.toFixed(3);
    }

    function renderScoreboard() {
      if (scoreTotalEl) scoreTotalEl.textContent = String(detectorStats.totalRounds);
      if (scoreRightEl) scoreRightEl.textContent = String(detectorStats.correct);
      if (scoreWrongEl) scoreWrongEl.textContent = String(detectorStats.wrong);
      if (scoreHumanRoundsEl) scoreHumanRoundsEl.textContent = String(detectorStats.humanRounds);
      if (scoreAiRoundsEl) scoreAiRoundsEl.textContent = String(detectorStats.aiRounds);
      if (scoreCalibrationValueEl) scoreCalibrationValueEl.textContent = getBrierScore(detectorStats);

      if (sessionScoreTotalEl) sessionScoreTotalEl.textContent = String(sessionDetectorStats.totalRounds);
      if (sessionScoreRightEl) sessionScoreRightEl.textContent = String(sessionDetectorStats.correct);
      if (sessionScoreWrongEl) sessionScoreWrongEl.textContent = String(sessionDetectorStats.wrong);
      if (sessionScoreHumanRoundsEl) sessionScoreHumanRoundsEl.textContent = String(sessionDetectorStats.humanRounds);
      if (sessionScoreAiRoundsEl) sessionScoreAiRoundsEl.textContent = String(sessionDetectorStats.aiRounds);
      if (sessionScoreCalibrationValueEl) sessionScoreCalibrationValueEl.textContent = getBrierScore(sessionDetectorStats);
    }

    function shuffleCopy(items) {
      const arr = items.slice();
      for (let i = arr.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        const tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
      }
      return arr;
    }

    function pickDetectorQuestions() {
      return shuffleCopy(detectorQuestionPool).slice(0, 4);
    }

    function getDetectorQuestions() {
      return detectorState.questions.length ? detectorState.questions : detectorQuestionPool.slice(0, 4);
    }

    function setDetectorStatus(text) {
      if (detectorStatusEl) detectorStatusEl.textContent = text;
    }

    function setDetectorControlsDisabled(disabled) {
      detectorState.busy = disabled;
      if (playHumanBtn) playHumanBtn.disabled = disabled;
      if (watchAiBtn) watchAiBtn.disabled = disabled;
      if (detectorSend) detectorSend.disabled = disabled;
    }

    function appendDetectorLine(label, text, isVerdict) {
      if (!detectorLogEl) return;
      const row = document.createElement("div");
      row.className = isVerdict ? "detector-line verdict" : "detector-line";
      row.innerHTML = `<div class="label">${label}</div><div>${text}</div>`;
      detectorLogEl.appendChild(row);
      detectorLogEl.scrollTop = detectorLogEl.scrollHeight;
    }

    function removeDetectorTyping() {
      const t = document.getElementById("detector-typing");
      if (t) t.remove();
    }

    function showDetectorTyping(label, text) {
      removeDetectorTyping();
      if (!detectorLogEl) return;
      const row = document.createElement("div");
      row.className = "detector-line";
      row.id = "detector-typing";
      row.innerHTML = `<div class="label">${label}</div><div class="typing">${text}</div>`;
      detectorLogEl.appendChild(row);
      detectorLogEl.scrollTop = detectorLogEl.scrollHeight;
    }

    function sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }

    function answerRevealDelay(answerText) {
      const base = 1200;
      const perChar = Math.min(2200, Math.max(300, String(answerText || "").length * 14));
      const jitter = Math.floor(Math.random() * 600);
      return base + perChar + jitter;
    }

    function resetDetector() {
      detectorState.mode = null;
      detectorState.step = 0;
      detectorState.answers = [];
      detectorState.watching = false;
      detectorState.busy = false;
      detectorState.watchHistory = [];
      detectorState.playHistory = [];
      detectorState.currentQuestion = "";
      detectorState.questions = [];
      detectorState.playInterrogatorMeta = "";
      detectorState.watchInterrogatorMeta = "";
      detectorState.watchRespondentMeta = "";
      if (detectorLogEl) detectorLogEl.innerHTML = "";
      if (detectorInputRow) detectorInputRow.classList.add("is-hidden");
      if (detectorInput) detectorInput.value = "";
      if (playHumanBtn) playHumanBtn.disabled = false;
      if (watchAiBtn) watchAiBtn.disabled = false;
      if (detectorSend) detectorSend.disabled = false;
      setDetectorStatus("Choose a mode to start.");
    }

    async function startHumanGame() {
      resetDetector();
      detectorState.mode = "human";
      detectorState.questions = pickDetectorQuestions();
      setDetectorStatus("Mode: Play yourself. Interrogator is thinking...");
      if (detectorInputRow) detectorInputRow.classList.remove("is-hidden");
      if (detectorSend) detectorSend.disabled = true;
      await requestNextHumanQuestion();
      if (detectorInput) detectorInput.focus();
    }

    async function requestNextHumanQuestion() {
      if (detectorState.mode !== "human") return;
      const turn = detectorState.playHistory.length;
      const questions = getDetectorQuestions();
      if (turn >= questions.length) {
        await endRound(detectorState.playHistory, "Human");
        return;
      }

      try {
        const payload = await callWorkerPath("/detector/play-turn", {
          questions,
          qa_pairs: detectorState.playHistory,
          turn_index: turn,
          interrogator_meta: detectorState.playInterrogatorMeta
        });
        if (!payload || payload.done || !payload.question) {
          throw new Error("Missing question in play-turn response.");
        }
        if (typeof payload.interrogator_meta === "string") {
          detectorState.playInterrogatorMeta = payload.interrogator_meta;
        }
        detectorState.currentQuestion = payload.question;
        appendDetectorLine("interrogator", payload.question, false);
        setDetectorStatus(`Mode: Play yourself. Question ${turn + 1}/${questions.length}.`);
        if (detectorSend) detectorSend.disabled = false;
      } catch (e) {
        setDetectorStatus("Could not fetch next question.");
        appendDetectorLine("error", "Interrogator request failed. Try reset and start again.", true);
        if (detectorSend) detectorSend.disabled = true;
      }
    }

    async function submitHumanAnswer() {
      if (detectorState.mode !== "human" || detectorState.busy || !detectorInput || !detectorPanel.classList.contains("active")) return;
      const text = detectorInput.value.trim();
      if (!text) return;
      if (!detectorState.currentQuestion) return;

      appendDetectorLine("you", text, false);
      detectorState.playHistory.push({ question: detectorState.currentQuestion, answer: text });
      detectorState.currentQuestion = "";
      detectorInput.value = "";
      if (detectorSend) detectorSend.disabled = true;
      setDetectorStatus("Mode: Play yourself. Interrogator is thinking...");
      await requestNextHumanQuestion();
      if (detectorInput) detectorInput.focus();
    }

    async function startWatchGame() {
      resetDetector();
      detectorState.mode = "watch";
      detectorState.questions = pickDetectorQuestions();
      detectorState.watching = true;
      setDetectorControlsDisabled(true);
      setDetectorStatus("Mode: Watch AI play. Running two-model simulation...");

      try {
        const watchPairs = [];
        let hiddenProfile = "";
        let watchMeta = null;

        const questions = getDetectorQuestions();
        for (let turn = 0; turn < questions.length; turn += 1) {
          if (!detectorState.watching) break;
          setDetectorStatus(`Mode: Watch AI play. Interrogator is thinking (${turn + 1}/${questions.length})...`);

          const turnPayload = await callWorkerPath("/detector/watch-turn", {
            questions,
            qa_pairs: watchPairs,
            turn_index: turn,
            hidden_profile: hiddenProfile,
            interrogator_meta: detectorState.watchInterrogatorMeta,
            respondent_meta: detectorState.watchRespondentMeta
          });

          if (turnPayload && turnPayload.meta) watchMeta = turnPayload.meta;
          if (turnPayload && turnPayload.done) break;
          if (!turnPayload || !turnPayload.question || !turnPayload.answer) {
            throw new Error("Missing turn question/answer in watch-turn response.");
          }
          hiddenProfile = typeof turnPayload.hidden_profile === "string" ? turnPayload.hidden_profile : hiddenProfile;
          if (typeof turnPayload.interrogator_meta === "string") {
            detectorState.watchInterrogatorMeta = turnPayload.interrogator_meta;
          }
          if (typeof turnPayload.respondent_meta === "string") {
            detectorState.watchRespondentMeta = turnPayload.respondent_meta;
          }

          appendDetectorLine("interrogator", turnPayload.question, false);
          setDetectorStatus(`Mode: Watch AI play. Respondent is thinking (${turn + 1}/${questions.length})...`);
          showDetectorTyping("respondent", "thinking...");
          await sleep(answerRevealDelay(turnPayload.answer));
          removeDetectorTyping();
          appendDetectorLine("respondent", turnPayload.answer, false);
          watchPairs.push({ question: turnPayload.question, answer: turnPayload.answer });
        }

        if (!watchPairs.length) {
          throw new Error("Watch mode produced no transcript turns.");
        }

        detectorState.watchHistory = watchPairs;
        await endRound(watchPairs, "AI");
        if (watchMeta && watchMeta.interrogator_model && watchMeta.respondent_model) {
          appendDetectorLine("models", `Interrogator: ${watchMeta.interrogator_model}. Respondent: ${watchMeta.respondent_model}.`, true);
        }
      } catch (e) {
        removeDetectorTyping();
        setDetectorStatus("Could not run watch mode right now.");
        appendDetectorLine("error", "Worker request failed. Check worker deploy/keys and try again.", true);
      }

      removeDetectorTyping();
      detectorState.watching = false;
      setDetectorControlsDisabled(false);
    }

    function applyLocalRoundUpdate(verdict, groundTruth) {
      const correct = verdict.guess === groundTruth;
      const numericConfidence = Number.isFinite(verdict.confidence) ? verdict.confidence : 70;
      const confidence = Math.max(0.5, Math.min(0.99, numericConfidence / 100));
      const pAi = verdict.guess === "AI" ? confidence : 1 - confidence;
      const yAi = groundTruth === "AI" ? 1 : 0;
      const brier = Math.pow(pAi - yAi, 2);

      detectorStats.totalRounds += 1;
      detectorStats.correct += correct ? 1 : 0;
      detectorStats.wrong += correct ? 0 : 1;
      detectorStats.humanRounds += groundTruth === "Human" ? 1 : 0;
      detectorStats.aiRounds += groundTruth === "AI" ? 1 : 0;
      detectorStats.brierSum += brier;
      sessionDetectorStats.totalRounds += 1;
      sessionDetectorStats.correct += correct ? 1 : 0;
      sessionDetectorStats.wrong += correct ? 0 : 1;
      sessionDetectorStats.humanRounds += groundTruth === "Human" ? 1 : 0;
      sessionDetectorStats.aiRounds += groundTruth === "AI" ? 1 : 0;
      sessionDetectorStats.brierSum += brier;
      renderScoreboard();
      return correct;
    }

    async function recordRound(verdict, groundTruth) {
      const correctLocal = applyLocalRoundUpdate(verdict, groundTruth);
      try {
        const payload = await callWorkerPath("/detector/stats/record", {
          guess: verdict.guess,
          confidence: verdict.confidence,
          groundTruth
        });
        if (payload && payload.stats) {
          detectorStats = normalizeStats(payload.stats);
          renderScoreboard();
        }
        return !!(payload && payload.correct);
      } catch (e) {
        return correctLocal;
      }
    }

    async function endRound(qaPairs, groundTruth) {
      detectorState.watching = false;
      setDetectorControlsDisabled(true);
      if (detectorInputRow) detectorInputRow.classList.add("is-hidden");
      setDetectorStatus("Evaluating transcript...");

      const verdict = await getVerdict(qaPairs);
      const correct = await recordRound(verdict, groundTruth);

      setDetectorStatus(`Verdict: ${verdict.guess} (${verdict.confidence}% confidence)`);
      appendDetectorLine("verdict", `I think this respondent is ${verdict.guess.toLowerCase()} (${verdict.confidence}% confidence). ${verdict.reason}`, true);
      appendDetectorLine("result", `Actual identity: ${groundTruth}. The detector got it ${correct ? "right" : "wrong"}.`, true);
      setDetectorControlsDisabled(false);
    }

    async function callWorkerPath(path, payload) {
      const res = await fetch(`${WORKER_URL}${path}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload || {})
      });
      const data = await res.json();
      if (!res.ok) {
        const msg = data && data.message ? data.message : `HTTP ${res.status}`;
        throw new Error(msg);
      }
      return data;
    }

    function parseVerdictJson(raw) {
      const cleaned = String(raw || "")
        .replace(/```json/gi, "")
        .replace(/```/g, "")
        .trim();

      try {
        const direct = JSON.parse(cleaned);
        if (direct && direct.guess) return direct;
      } catch (e) {}

      const match = cleaned.match(/\{[\s\S]*\}/);
      if (!match) return null;
      try {
        const parsed = JSON.parse(match[0]);
        return parsed && parsed.guess ? parsed : null;
      } catch (e) {
        const guessMatch = cleaned.match(/\b(ai|human)\b/i);
        const confMatch = cleaned.match(/(\d{2,3})\s*%?/);
        const reasonMatch = cleaned.match(/reason[:\-]\s*(.+)$/im);
        if (!guessMatch) return null;
        return {
          guess: guessMatch[1].toUpperCase() === "AI" ? "AI" : "Human",
          confidence: confMatch ? Number(confMatch[1]) : 70,
          reason: reasonMatch ? reasonMatch[1].trim() : "Based on language cues in the responses."
        };
      }
    }

    async function getVerdict(qaPairs) {
      try {
        const payload = await callWorkerPath("/detector/verdict", {
          qa_pairs: qaPairs
        });
        if (payload && payload.verdict) {
          const v = payload.verdict;
          const guess = v.guess === "AI" ? "AI" : "Human";
          const confidence = Number.isFinite(v.confidence) ? Math.max(50, Math.min(99, Math.round(v.confidence))) : 70;
          const reason = typeof v.reason === "string" && v.reason.trim() ? v.reason.trim() : "The linguistic pattern suggested this classification.";
          return { guess, confidence, reason };
        }
      } catch (e) {
        // Fallback to previous root endpoint behavior if worker routes are not deployed yet.
      }

      const transcript = qaPairs.map((pair, index) => {
        const question = pair && pair.question ? pair.question : "";
        const answer = pair && pair.answer ? pair.answer : "";
        return `${index + 1}. Q: ${question}\nA: ${answer}`;
      }).join("\n\n");

      const systemPrompt = "You are an interrogator classifying whether a respondent is AI or human from short answers. Output one single-line JSON object only, no markdown, no extra text. Keys: guess, confidence, reason. guess must be AI or Human. confidence must be integer 50-99. reason must be one sentence.";
      const userPrompt = `Classify this transcript:\n\n${transcript}`;

      try {
        const legacy = await callWorkerPath("", {
          messages: [
            { role: "system", content: systemPrompt },
            { role: "user", content: userPrompt }
          ]
        });
        const text = legacy && legacy.content && legacy.content[0] ? legacy.content[0].text : "";
        const parsed = parseVerdictJson(text || "");
        if (parsed) {
          const guess = parsed.guess === "AI" ? "AI" : "Human";
          const confidence = Number.isFinite(parsed.confidence) ? Math.max(50, Math.min(99, Math.round(parsed.confidence))) : 70;
          const reason = typeof parsed.reason === "string" && parsed.reason.trim() ? parsed.reason.trim() : "The linguistic pattern suggested this classification.";
          return { guess, confidence, reason };
        }
      } catch (e) {}

      return {
        guess: "Human",
        confidence: 65,
        reason: "Could not confidently parse the model output, so this is a safe default."
      };
    }

    function traitorsAlivePlayers() {
      if (!traitorsState || !Array.isArray(traitorsState.players)) return [];
      return traitorsState.players.filter((p) => p.alive);
    }

    function traitorsAliveAIs() {
      return traitorsAlivePlayers().filter((p) => !p.isHuman);
    }

    function appendTraitorsLine(label, text) {
      if (!traitorsLogEl) return;
      const row = document.createElement("div");
      row.className = "traitors-line";
      row.innerHTML = `<div class="label">${label}</div><div>${text}</div>`;
      traitorsLogEl.appendChild(row);
      traitorsLogEl.scrollTop = traitorsLogEl.scrollHeight;
    }

    function renderTraitorsScene() {
      if (!traitorsSceneEl) return;
      const oldSeats = traitorsSceneEl.querySelectorAll(".traitors-seat");
      oldSeats.forEach((seat) => seat.remove());
      if (!traitorsState || !Array.isArray(traitorsState.players)) return;

      const players = traitorsState.players.slice();
      const count = players.length || 1;
      const radius = 112;
      players.forEach((p, index) => {
        const seat = document.createElement("div");
        seat.className = `traitors-seat${p.isHuman ? " human" : ""}${p.alive ? "" : " dead"}`;
        seat.style.setProperty("--angle", `${(index * 360) / count}deg`);
        seat.style.setProperty("--radius", `${radius}px`);
        seat.textContent = p.isHuman ? `${p.name} (Traitor)` : p.name;
        traitorsSceneEl.appendChild(seat);
      });
    }

    function updateTraitorsControls() {
      const canAct = !!traitorsState && !traitorsBusy && traitorsState.phase !== "ended";
      const banishment = canAct && traitorsState.phase === "banishment";
      const night = canAct && traitorsState.phase === "night";
      if (traitorsStatementEl) traitorsStatementEl.disabled = !banishment;
      if (traitorsVoteEl) traitorsVoteEl.disabled = !banishment;
      if (traitorsBanishBtn) traitorsBanishBtn.disabled = !banishment;
      if (traitorsMurderEl) traitorsMurderEl.disabled = !night;
      if (traitorsNightBtn) traitorsNightBtn.disabled = !night;
    }

    function populateTraitorsSelects() {
      if (!traitorsState) return;
      const alive = traitorsAlivePlayers();
      const aliveAIs = traitorsAliveAIs();

      if (traitorsVoteEl) {
        const current = traitorsVoteEl.value;
        traitorsVoteEl.innerHTML = "";
        alive.filter((p) => !p.isHuman).forEach((p) => {
          const opt = document.createElement("option");
          opt.value = p.id;
          opt.textContent = p.name;
          traitorsVoteEl.appendChild(opt);
        });
        if (current && [...traitorsVoteEl.options].some((o) => o.value === current)) {
          traitorsVoteEl.value = current;
        }
      }

      if (traitorsMurderEl) {
        const current = traitorsMurderEl.value;
        traitorsMurderEl.innerHTML = "";
        aliveAIs.forEach((p) => {
          const opt = document.createElement("option");
          opt.value = p.id;
          opt.textContent = p.name;
          traitorsMurderEl.appendChild(opt);
        });
        if (current && [...traitorsMurderEl.options].some((o) => o.value === current)) {
          traitorsMurderEl.value = current;
        }
      }
    }

    function announceTraitorsWinnerIfAny() {
      if (!traitorsState || traitorsState.phase !== "ended" || !traitorsState.winner) return;
      if (traitorsState.winner === "human") {
        appendTraitorsLine("host", "You made it to the end. Traitor win.");
      } else {
        appendTraitorsLine("host", "The Faithful banished you. AI win.");
      }
    }

    function renderTraitorsUI() {
      renderTraitorsScene();
      populateTraitorsSelects();
      updateTraitorsControls();
    }

    function setTraitorsBusy(value) {
      traitorsBusy = value;
      updateTraitorsControls();
    }

    async function startTraitorsGame() {
      if (traitorsBusy) return;
      setTraitorsBusy(true);
      if (traitorsLogEl) traitorsLogEl.innerHTML = "";
      try {
        const payload = await callWorkerPath("/traitors/start", { ai_count: 4 });
        traitorsState = payload && payload.state ? payload.state : null;
        renderTraitorsUI();
        appendTraitorsLine("host", payload && payload.host_line ? payload.host_line : "Welcome to the round table.");
      } catch (e) {
        appendTraitorsLine("system", "Could not start game.");
      }
      setTraitorsBusy(false);
    }

    function resetTraitorsGame() {
      traitorsState = null;
      if (traitorsLogEl) traitorsLogEl.innerHTML = "";
      if (traitorsVoteEl) traitorsVoteEl.innerHTML = "";
      if (traitorsMurderEl) traitorsMurderEl.innerHTML = "";
      if (traitorsStatementEl) traitorsStatementEl.value = "";
      renderTraitorsScene();
      updateTraitorsControls();
    }

    async function runTraitorsBanishment() {
      if (traitorsBusy || !traitorsState || traitorsState.phase !== "banishment") return;
      const statement = traitorsStatementEl ? traitorsStatementEl.value.trim() : "";
      const vote = traitorsVoteEl ? traitorsVoteEl.value : "";
      if (statement) appendTraitorsLine("you", statement);

      setTraitorsBusy(true);
      try {
        const payload = await callWorkerPath("/traitors/banishment", {
          state: traitorsState,
          human_statement: statement,
          human_vote: vote
        });
        traitorsState = payload && payload.state ? payload.state : traitorsState;

        if (Array.isArray(payload && payload.ai_turns)) {
          payload.ai_turns.forEach((turn) => {
            appendTraitorsLine(turn.name || turn.id, turn.statement || "");
          });
        }
        if (payload && payload.host_line) appendTraitorsLine("host", payload.host_line);
        if (payload && payload.banished) {
          appendTraitorsLine("banished", `${payload.banished.name} was banished (${payload.banished.role}).`);
        }
        renderTraitorsUI();
        announceTraitorsWinnerIfAny();
      } catch (e) {
        appendTraitorsLine("system", "Banishment step failed.");
      }
      setTraitorsBusy(false);
    }

    async function runTraitorsNight() {
      if (traitorsBusy || !traitorsState || traitorsState.phase !== "night") return;
      const target = traitorsMurderEl ? traitorsMurderEl.value : "";
      setTraitorsBusy(true);
      try {
        const payload = await callWorkerPath("/traitors/night", {
          state: traitorsState,
          murder_target: target
        });
        traitorsState = payload && payload.state ? payload.state : traitorsState;
        if (payload && payload.murdered) {
          appendTraitorsLine("night", `You murdered ${payload.murdered.name}.`);
        }
        if (payload && payload.host_line) appendTraitorsLine("host", payload.host_line);
        renderTraitorsUI();
        announceTraitorsWinnerIfAny();
      } catch (e) {
        appendTraitorsLine("system", "Night step failed.");
      }
      setTraitorsBusy(false);
    }

    resetTraitorsGame();
  </script>
</body>
</html>
